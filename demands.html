<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Talepler</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' fill='%233b82f6' rx='6'/%3E%3Ctext x='16' y='22' font-family='Arial' font-size='18' font-weight='bold' text-anchor='middle' fill='white'%3ET%3C/text%3E%3C/svg%3E" />
  <link rel="stylesheet" href="/utils.css" />
  <link rel="stylesheet" href="/assets/css/layout.css" />
  <link rel="stylesheet" href="/css/ui-standard.css" />
</head>
<body>
  <!-- Common Header -->
  <header id="app-header"></header>

  <!-- Page Header -->
  <header class="page-header">
    <div class="container">
      <div class="header-left">
        <nav class="breadcrumb">
          <a href="./dashboard.html">Dashboard</a>
          <span class="separator">›</span>
          <span class="current">Talepler</span>
        </nav>
      </div>
      <div class="header-right">
        <a href="#" class="company-chip" id="companyChip">
          <div class="company-icon">T</div>
          <div>
            <div class="company-name" id="companyName">Yükleniyor...</div>
            <div class="company-email" id="companyEmail">-</div>
          </div>
        </a>
      </div>
    </div>
  </header>

  <div class="container--wide" style="padding:0 20px 20px">
    <nav class="tb-breadcrumb">
      <span class="tb-crumb"><span class="ico">🏠</span><a href="./index.html">Ana Sayfa</a></span>
      <span class="tb-sep">›</span>
      <span class="tb-crumb"><span class="ico">📄</span><a href="./demands.html">Talepler</a></span>
    </nav>
    <h1 class="page-title">Tüm Talepler</h1>
    
    <!-- Toolbar -->
    <div class="toolbar card">
      <div class="toolbar-content">
        <div class="toolbar-left">
          <form class="search-form" id="searchForm">
            <label for="searchInput" class="search-label">SATFK ile Ara</label>
            <input type="text" id="searchInput" class="search-input" placeholder="Örn. SATFK-20251024-00C9" title="SATFK kodunu girin (örnek: SATFK-20251024-00C9)" />
            <button type="submit" id="searchBtn" class="btn btn-primary">Ara</button>
            <button type="button" id="clearSearchBtn" class="btn btn-outline">Temizle</button>
          </form>
        </div>
        <div class="toolbar-right">
          <a href="./demand-new.html" class="btn btn-primary">+ Yeni Talep</a>
        </div>
      </div>
    </div>

  <!-- Tabs -->
  <div class="tabs" style="display:flex;gap:8px;margin:12px 0;">
    <button id="tabIncoming" class="tab active">Gelen Talepler</button>
    <button id="tabOutgoing" class="tab">Giden Talepler</button>
    <button id="tabDraft" class="tab">Taslak Talepler</button>
  </div>
  <style>
    .tab{padding:8px 12px;border:1px solid #e5e7eb;border-radius:8px;background:#fff;cursor:pointer;font-weight:600;color:#111827}
    .tab:hover{background:#f3f4f6}
    .tab.active{background:#2563eb;color:#ffffff;border-color:#2563eb}
    .hidden{display:none}
    table{width:100%;border-collapse:collapse;table-layout:auto}
    th,td{padding:12px 8px;border-bottom:1px solid #e5e7eb;text-align:left}
    th{background:#f9fafb;font-weight:600}
    td{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    /* Kategori hücresi sarılsın, uzun listeler sayfaya sığsın */
    .td-cats{white-space:normal;word-break:break-word;max-width:380px}
    /* Search UI */
    .search-form{display:flex;gap:8px;align-items:center}
    .search-label{font-size:13px;font-weight:600;color:#374151}
    .search-input{padding:8px 10px;border:1px solid #d1d5db;border-radius:8px;min-width:340px}
    @media(max-width:640px){.search-input{min-width:200px;width:100%}}
    /* Category chips */
    .cat-chip{display:inline-block;background:#e0f2fe;color:#0277bd;padding:2px 6px;margin:0 4px 4px 0;border-radius:12px;font-size:12px;white-space:nowrap}
    .cat-more{position:relative;display:inline-block}
    .cat-toggle{background:transparent;border:0;color:#2563eb;cursor:pointer;font-size:12px;padding:0 4px}
    .cat-more .cat-tip{display:none;position:absolute;left:0;top:115%;background:#ffffff;border:1px solid #e5e7eb;box-shadow:0 8px 20px rgba(0,0,0,.08);padding:8px;border-radius:8px;max-width:360px;z-index:50;white-space:normal}
    .cat-more:hover .cat-tip{display:block}
  </style>

  <!-- Filters and Grouping Controls -->
  <div style="display:flex; gap:16px; margin:16px 0; flex-wrap:wrap; align-items:center; padding:12px; background:#f9fafb; border-radius:6px;">
    <!-- Gelen Talepler için filtreler -->
    <div id="incoming-filters" class="hidden">
      <label for="f-incoming-status" style="font-size:13px; font-weight:600; margin-right:6px;">Durum:</label>
      <select id="f-incoming-status" style="padding:6px; border-radius:4px;">
        <option value="">— Tümü —</option>
        <option value="pending">Bekleyen</option>
        <option value="viewed">Görüldü</option>
        <option value="responded">Yanıtlandı</option>
      </select>
    </div>
    
    <!-- Giden Talepler için filtreler -->
    <div id="outgoing-filters">
      <label for="f-status" style="font-size:13px; font-weight:600; margin-right:6px;">Durum:</label>
      <select id="f-status" style="padding:6px; border-radius:4px;">
        <option value="">— Tümü —</option>
        <option value="draft">Taslak</option>
        <option value="published">Gönderildi</option>
      </select>
    </div>
    
    <div>
      <label for="f-priority" style="font-size:13px; font-weight:600; margin-right:6px;">Öncelik:</label>
      <select id="f-priority" style="padding:6px; border-radius:4px;">
        <option value="">— Tümü —</option>
        <option value="price">Fiyat</option>
        <option value="speed">Hız</option>
        <option value="quality">Kalite</option>
      </select>
    </div>
    
    <div>
      <label for="f-biddingmode" style="font-size:13px; font-weight:600; margin-right:6px;">Talep Tipi:</label>
      <select id="f-biddingmode" style="padding:6px; border-radius:4px;">
        <option value="">— Tümü —</option>
        <option value="secret">Gizli</option>
        <option value="open">Açık Artırma</option>
        <option value="hybrid">Hibrit</option>
      </select>
    </div>
    
    <div id="group-controls" style="display:flex; gap:8px; align-items:center;">
      <label for="f-group" style="font-size:13px; font-weight:600;">Grupla:</label>
      <select id="f-group" style="padding:6px; border-radius:4px;">
        <option value="">— Yok —</option>
        <option value="site">Şantiye</option>
        <option value="category">Kategori</option>
        <option value="status">Durum</option>
        <option value="priority">Öncelik</option>
        <option value="biddingmode">Talep Tipi</option>
        <option value="month">Oluşturma Ayı</option>
      </select>
    </div>
  </div>

  <!-- Incoming Demands Section -->
  <section id="incomingDemands">
    <div style="margin: 8px 0 4px 0; font-weight: 700; color:#111827;">Teklif Verilenler</div>
    <div class="table-responsive">
      <table>
        <thead>
          <tr><th>SATFK</th><th>Başlık</th><th>Firma</th><th>Kategoriler</th><th>Termin</th><th>Durum</th><th>Teklif Sayısı</th><th></th></tr>
        </thead>
        <tbody id="incomingRowsGiven"></tbody>
      </table>
    </div>

    <div style="margin: 16px 0 4px 0; font-weight: 700; color:#111827;">Bekleyenler</div>
    <div class="table-responsive">
      <table>
        <thead>
          <tr><th>SATFK</th><th>Başlık</th><th>Firma</th><th>Kategoriler</th><th>Termin</th><th>Durum</th><th>Teklif Sayısı</th><th></th></tr>
        </thead>
        <tbody id="incomingRowsWaiting"></tbody>
      </table>
    </div>
    <div id="incomingEmpty" class="hidden" style="padding:16px;color:#64748b">Gelen talep yok.</div>
  </section>

  <!-- Outgoing Demands Section -->
  <section id="outgoingDemands" class="hidden">
    <div class="table-responsive">
      <table>
      <thead><tr><th>SATFK</th><th>Başlık</th><th>Kategoriler</th><th>Termin</th><th>Durum</th><th>Teklif Sayısı</th><th></th></tr></thead>
      <tbody id="outgoingRows"></tbody>
      </table>
    </div>
    <div id="outgoingEmpty" class="hidden" style="padding:16px;color:#64748b">Oluşturduğunuz talep yok.</div>
  </section>

  <!-- Draft Demands Section -->
  <section id="draftDemands" class="hidden">
    <div style="margin-bottom: 16px; padding: 12px; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px;">
      <h3 style="margin: 0 0 8px 0; color: #92400e; font-size: 16px;">📝 Taslak Talepler</h3>
      <p style="margin: 0; color: #92400e; font-size: 14px;">
        Henüz onaylanmamış talepleriniz. Bu talepleri düzenleyebilir, onaylayabilir veya silebilirsiniz.
      </p>
    </div>
    <div class="table-responsive">
      <table>
        <thead>
          <tr>
            <th style="width:34px; text-align:center;"><input type="checkbox" id="draftSelectAll"></th>
            <th>SATFK</th><th>Başlık</th><th>Kategoriler</th><th>Termin</th><th>Durum</th><th>Teklif Sayısı</th><th>İşlemler</th>
          </tr>
        </thead>
        <tbody id="draftRows"></tbody>
      </table>
    </div>
    <div id="draftBulkActions" style="margin-top:8px; display:flex; gap:8px;">
      <button id="btnDeleteSelectedDrafts" style="padding:6px 10px; background:#ef4444; color:#fff; border:none; border-radius:4px; cursor:pointer;">Seçilenleri Sil</button>
      <button id="btnClearDraftSelection" style="padding:6px 10px; background:#e5e7eb; color:#111827; border:none; border-radius:4px; cursor:pointer;">Seçimi Temizle</button>
    </div>
    <div id="draftEmpty" class="hidden" style="padding:16px;color:#64748b">Taslak talebiniz yok.</div>
    <div id="loadMoreDraftsBtn" class="hidden" style="text-align: center; margin: 20px 0;">
      <button onclick="loadMoreDrafts()" style="padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
        📄 Daha Fazla Yükle
      </button>
    </div>
  </section>

  <!-- Regular Table View (hidden by default) -->
  <div class="table-responsive">
    <table class="table" id="tbl" style="display:none;">
    <thead>
      <tr>
        <th>SATFK</th>
        <th>Başlık</th>
        <th>Kategoriler</th>
        <th>Termin</th>
        <th>Öncelik</th>
        <th>Talep Tipi</th>
        <th>Şantiye</th>
        <th>Durum</th>
        <th>Oluşturma</th>
        <th>Aksiyonlar</th>
      </tr>
    </thead>
    <tbody id="demands-body"></tbody>
    </table>
  </div>

  <!-- Grouped View Container -->
  <div id="grouped-container" style="display:none;"></div>
  
  <!-- Pagination -->
  <div id="pager" style="margin:20px 0; text-align:center;"></div>
  </div><!-- End container -->

  <!-- Main Script -->
  <script type="module">
    import { initGlobalHeader } from './assets/js/ui/header.js';
    import { db, auth } from "./firebase.js";
    import { doc, getDoc } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";
    
    // Initialize global header
    initGlobalHeader({ mount: '#app-header', activeRoute: 'demands' });
    
    // Fill company chip
    async function fillCompanyChip() {
      try {
        const user = auth.currentUser;
        if (!user) return;
        
        const collections = ['profiles', 'users', 'publicProfiles'];
        let companyName = 'Şirket Adı Yok';
        let userEmail = user.email || '';
        
        for (const collection of collections) {
          try {
            const profileSnap = await getDoc(doc(db, collection, user.uid));
            if (profileSnap.exists()) {
              const profileData = profileSnap.data();
              const name = profileData?.companyName || 
                          profileData?.company?.name || 
                          profileData?.displayName ||
                          profileData?.name;
              
              if (name && name.trim()) {
                companyName = name.trim();
                break;
              }
            }
          } catch (error) {
            console.warn(`Profile collection ${collection} okunamadı:`, error.message);
            continue;
          }
        }
        
        // Update company chip
        const companyNameEl = document.getElementById('companyName');
        const companyEmailEl = document.getElementById('companyEmail');
        
        if (companyNameEl) companyNameEl.textContent = companyName;
        if (companyEmailEl) companyEmailEl.textContent = userEmail;
        
        console.log(`🏢 Company chip updated: ${companyName}`);
      } catch (error) {
        console.error('Company chip fill error:', error);
      }
    }
    
    // Initialize company chip
    if (auth.currentUser) {
      await fillCompanyChip();
    } else {
      const unsub = auth.onAuthStateChanged(async (user) => {
        if (user) {
          await fillCompanyChip();
          unsub();
        }
      });
    }
  </script>

  <!-- Main Demands Script -->
  <script type="module">
    import { db, requireAuth, logout } from "./firebase.js";
    import {
      collection, getDocs, getDoc, query, where, deleteDoc, doc, orderBy, limit, startAfter,
      updateDoc, arrayUnion, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";
    
    (async () => {

    // --- UI refs ---
    const tbody        = document.getElementById("demands-body");
    const groupedWrap  = document.getElementById("grouped-container");
    const pager        = document.getElementById("pager");
    const fStatus      = document.getElementById("f-status");
    const fPriority    = document.getElementById("f-priority");
    const fBiddingMode = document.getElementById("f-biddingmode");
    const fGroup       = document.getElementById("f-group");
    
    // Gelen talepler için filtreler
    const fIncomingStatus = document.getElementById("f-incoming-status");
    const incomingFilters = document.getElementById("incoming-filters");
    const outgoingFilters = document.getElementById("outgoing-filters");

    // --- Auth ---
    const user = await requireAuth();
    const uid  = user.uid;

    // Durum çevirisi fonksiyonu
    function translateStatus(status) {
      const statusMap = {
        'draft': 'Taslak',
        'approved': 'Onaylandı',
        'published': 'Yayınlandı',
        'sent': 'Gönderildi',
        'pending': 'Bekleyen',
        'viewed': 'Görüldü',
        'responded': 'Yanıtlandı',
        'rejected': 'Reddedildi',
        'cancelled': 'İptal Edildi',
        'completed': 'Tamamlandı',
        'in_progress': 'Devam Ediyor',
        'closed': 'Kapatıldı'
      };
      return statusMap[status] || status || 'Bilinmeyen';
    }

    // State
    let merged = [];
    const PAGE_SIZE = 20;
    let currentPage = 0;
    
    // Draft pagination state
    let lastDraftDoc = null;
    let accumulatedDrafts = [];
    let isLoadingDrafts = false;
    let draftsFinished = false;
    const DRAFT_PAGE_SIZE = 10;

    // Helper: slug normalize (tr-friendly)
    function toSlug(name){
      if (!name) return '';
      return String(name)
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/[şŞ]/g,'s').replace(/[ıİ]/g,'i').replace(/[ğĞ]/g,'g')
        .replace(/[çÇ]/g,'c').replace(/[öÖ]/g,'o').replace(/[üÜ]/g,'u')
        .toLowerCase().trim().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
    }

    // Prefer real company name over placeholders
    function pickCompanyName({ demandRow, creatorProfile, companyDoc }) {
      const candidates = [
        demandRow?.companyName,
        demandRow?.company?.name,
        companyDoc?.name,
        creatorProfile?.companyName,
        creatorProfile?.company?.name,
        creatorProfile?.settings?.companyName,
        creatorProfile?.profile?.companyName,
        creatorProfile?.companyTitle,
        creatorProfile?.company_name
      ]
      .map(v => (typeof v === 'string' ? v.trim() : v))
      .filter(Boolean);

      const cleaned = candidates.find(n => n && n.toLowerCase() !== 'kendi firmam');
      return cleaned || '—';
    }

    // Render categories: show top 3 chips, expandable to all
    function renderCategoriesCell(cats = []){
      const arr = (Array.isArray(cats) ? cats : []).filter(Boolean);
      const top = arr.slice(0,3);
      const rest = arr.slice(3);
      const chip = (t) => `<span class="cat-chip">${t}</span>`;
      let html = top.map(chip).join(' ');
      if (rest.length) {
        const payload = encodeURIComponent(JSON.stringify(rest));
        const tipHtml = rest.map(chip).join(' ');
        html += ` <span class="cat-more"><button class="cat-toggle" data-rest="${payload}">+${rest.length}</button><div class="cat-tip">${tipHtml}</div></span>`;
      }
      return html || '-';
    }
    // Expand handler (event delegation)
    document.addEventListener('click', (e)=>{
      const btn = e.target.closest?.('.cat-toggle');
      if (!btn) return;
      const wrap = btn.parentElement; if (!wrap) return;
      try {
        const rest = JSON.parse(decodeURIComponent(btn.getAttribute('data-rest') || '%5B%5D'));
        const current = Array.from(wrap.querySelectorAll('.cat-chip')).map(n=>n.textContent);
        const all = [...current, ...rest];
        wrap.innerHTML = all.map(t=>`<span class=\"cat-chip\">${t}</span>`).join(' ');
      } catch(_){}
    });

    // Load first item meta (name, image, target price) for a set of demands
    async function loadFirstItemMeta(rows){
      const cache = new Map();
      await Promise.all(rows.map(async (r)=>{
        try{
          const qItem = query(collection(db,'demands', r.id, 'items'), orderBy('lineNo','asc'), limit(1));
          const s = await getDocs(qItem);
          if (!s.empty){
            const it = s.docs[0].data();
            const img = it.imageUrl || it.image || null;
            const target = it.targetUnitPrice || it.targetPrice || r.targetPrice || null;
            r._firstItem = { name: it.name || it.description || '', imageUrl: img, target };
            cache.set(r.id, r._firstItem);
          } else {
            r._firstItem = { name: '', imageUrl: null, target: r.targetPrice || null };
          }
        }catch(e){ r._firstItem = { name:'', imageUrl:null, target: r.targetPrice || null }; }
      }));
      return rows;
    }

    // Tab functionality
    function showTab(which){
      document.getElementById('tabIncoming').classList.toggle('active', which==='incoming');
      document.getElementById('tabOutgoing').classList.toggle('active', which==='outgoing');
      document.getElementById('tabDraft').classList.toggle('active', which==='draft');
      
      document.getElementById('incomingDemands').classList.toggle('hidden', which!=='incoming');
      document.getElementById('outgoingDemands').classList.toggle('hidden', which!=='outgoing');
      document.getElementById('draftDemands').classList.toggle('hidden', which!=='draft');
      
      // Filtreleri göster/gizle
      if (which === 'incoming') {
        incomingFilters.classList.remove('hidden');
        outgoingFilters.classList.add('hidden');
      } else if (which === 'outgoing') {
        incomingFilters.classList.add('hidden');
        outgoingFilters.classList.remove('hidden');
      } else if (which === 'draft') {
        incomingFilters.classList.add('hidden');
        outgoingFilters.classList.add('hidden');
      }
      
      // Hide the old table view when showing tabs
      document.getElementById('tbl').classList.add('hidden');
      document.getElementById('pager').style.display = 'none';
      document.getElementById('grouped-container').style.display = 'none';
    }
    
    document.getElementById('tabIncoming')?.addEventListener('click', ()=> showTab('incoming'));
    document.getElementById('tabOutgoing')?.addEventListener('click', ()=> showTab('outgoing'));
    document.getElementById('tabDraft')?.addEventListener('click', ()=> showTab('draft'));
    
    // Search functionality
    document.getElementById('searchBtn')?.addEventListener('click', (e)=>{ e.preventDefault?.(); searchBySATFK(); });
    document.getElementById('searchForm')?.addEventListener('submit', (e)=>{ e.preventDefault(); searchBySATFK(); });
    document.getElementById('clearSearchBtn')?.addEventListener('click', clearSearch);
    document.getElementById('searchInput')?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') searchBySATFK();
    });
    
    // Search by SATFK function
    async function searchBySATFK() {
      const searchInput = document.getElementById('searchInput');
      const satfk = searchInput.value.trim();
      
      if (!satfk) {
        alert('Lütfen bir SATFK girin');
        return;
      }
      
      // Validate SATFK format
      if (!satfk.match(/^SATFK-\d{8}-[0-9A-Z]+$/)) {
        alert('Geçersiz SATFK formatı. Örnek: SATFK-20251024-00C9');
        return;
      }
      
      try {
        // Search in all demands
        const q = query(
          collection(db, 'demands'),
          where('satfk', '==', satfk)
        );
        
        const snap = await getDocs(q);
        
        if (snap.empty) {
          alert('Bu SATFK ile talep bulunamadı');
          return;
        }
        
        const demand = snap.docs[0].data();
        const demandId = snap.docs[0].id;
        
        // Redirect to demand detail
        window.location.href = `./demand-detail.html?id=${demandId}`;
        
      } catch (error) {
        console.error('Arama hatası:', error);
        alert('Arama sırasında hata oluştu');
      }
    }
    
    // Clear search function
    function clearSearch() {
      document.getElementById('searchInput').value = '';
    }
    
    // Get URL parameters once for the entire page
    const urlParams = new URLSearchParams(window.location.search);
    
    // Check for search parameter in URL
    const searchQuery = urlParams.get('q');
    if (searchQuery) {
      document.getElementById('searchInput').value = searchQuery;
      searchBySATFK();
    }

    // Render function for draft demands (with action buttons)
    async function renderDraft(rows, tbodySel, emptySel){
      const tb = document.querySelector(tbodySel); 
      if (!tb) return;
      tb.innerHTML = '';
      
      if (rows.length === 0) {
        document.querySelector(emptySel).classList.remove('hidden');
        return;
      }
      
      document.querySelector(emptySel).classList.add('hidden');
      
      for (const r of rows) {
        const tr = document.createElement('tr');
        tr.dataset.id = r.id;
        
        const d = r.dueDate ? new Date(r.dueDate) : null;
        const statusText = translateStatus(r.statusText || r.status || 'draft');
        
        // Bid sayısını hesapla (async olarak)
        const bidCount = await (async () => {
          try {
            const bidQuery = query(collection(db, 'bids'), where('demandId', '==', r.id));
            const bidSnap = await getDocs(bidQuery);
            return bidSnap.docs.length;
          } catch (error) {
            console.warn(`Bid count error for demand ${r.id}:`, error);
            return 0;
          }
        })();
        
        const bidDisplay = bidCount > 0 
          ? `<span style="background:#d1fae5;color:#065f46;padding:2px 6px;border-radius:4px;font-size:12px">${bidCount} teklif</span>`
          : '<span style="color:#6b7280;font-size:12px">Henüz teklif yok</span>';
        
        tr.innerHTML = `
          <td style="text-align:center"><input type="checkbox" class="draft-select" data-id="${r.id}"></td>
          <td>${r.satfk || '-'}</td>
          <td>${r.title || '-'}</td>
          <td class="td-cats"><div class="cat-wrap">${renderCategoriesCell(r.categoryTags)}</div></td>
          <td>${d? d.toLocaleDateString('tr-TR') : '-'}</td>
          <td><span style="background: #fef3c7; color: #92400e; padding: 4px 8px; border-radius: 4px; font-size: 12px;">${statusText}</span></td>
          <td>${bidDisplay}</td>
          <td>
            <button onclick="editDraftDemand('${r.id}')" style="padding: 4px 8px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 4px;">
              ✏️ Düzenle
            </button>
            <button onclick="approveDraftDemand('${r.id}')" style="padding: 4px 8px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 4px;">
              ✅ Onayla
            </button>
            <button onclick="deleteDraftDemand('${r.id}')" style="padding: 4px 8px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
              🗑️ Sil
            </button>
          </td>
        `;
        tb.appendChild(tr);
      }
    }

    // Render function for tab tables
    async function render(rows, tbodySel, emptySel){
      const tb = document.querySelector(tbodySel); 
      if (!tb) return;
      tb.innerHTML = '';
      const emptyEl = document.querySelector(emptySel);
      if (!rows.length){ 
        if (emptyEl) emptyEl.classList.remove('hidden'); 
        return; 
      }
      if (emptyEl) emptyEl.classList.add('hidden');
      const isIncoming = (tbodySel === '#incomingRows');
      
      for (const r of rows) {
        // Normalize due date across different field shapes
        let d = null;
        if (r.dueDate?.toDate) d = r.dueDate.toDate();
        else if (r.dueDate) d = new Date(r.dueDate);
        else if (r.deadline?.toDate) d = r.deadline.toDate();
        else if (r.deadline) d = new Date(r.deadline);
        const tr = document.createElement('tr');
        
        // Durum gösterimi - gelen talepler için recipientStatus kullan
        let statusText;
        if (r.recipientStatus) {
          statusText = translateStatus(r.recipientStatus);
        } else {
          statusText = translateStatus(r.status || (r.isPublished ? 'published' : 'draft'));
        }
        
        // Bid sayısını hesapla (async olarak)
        const bidCount = await (async () => {
          try {
            const bidQuery = query(collection(db, 'bids'), where('demandId', '==', r.id));
            const bidSnap = await getDocs(bidQuery);
            return bidSnap.docs.length;
          } catch (error) {
            console.warn(`Bid count error for demand ${r.id}:`, error);
            return 0;
          }
        })();
        
        const bidDisplay = bidCount > 0 
          ? `<span style="background:#d1fae5;color:#065f46;padding:2px 6px;border-radius:4px;font-size:12px">${bidCount} teklif</span>`
          : '<span style="color:#6b7280;font-size:12px">Henüz teklif yok</span>';
        
        // Firma bilgisi sadece gelen taleplerde gösterilir
        const companyName = r.companyName || r.company?.name || 'Bilinmeyen Firma';
        const companyTd = isIncoming ? `<td><span style=\"background:#e0f2fe;color:#0277bd;padding:2px 6px;border-radius:4px;font-size:12px\">${companyName}</span></td>` : '';

        // Tablo sütunları hedef tabloya göre hizalanır
        const detailLink = (src) => `demand-detail.html?id=${encodeURIComponent(r.id)}&source=${src}`;
        const fi = r._firstItem || {};
        const thumb = fi.imageUrl ? `<img src="${fi.imageUrl}" alt="" style=\"width:44px;height:44px;object-fit:cover;border-radius:6px;border:1px solid #e5e7eb;margin-right:8px;\">` : '';
        const titleBlock = `
          <div style=\"display:flex;align-items:center;\">
            ${thumb}
            <div>
              <div style=\"font-weight:600;color:#111827;\">${r.title || '-'}</div>
              ${fi.target || r.targetPrice ? `<div style=\\\"font-size:12px;color:#6b7280;\\\">Hedef: ${(fi.target || r.targetPrice)}</div>` : ''}
            </div>
          </div>`;
        tr.innerHTML = isIncoming
          ? `
          <td>${r.satfk || '-'}</td>
          <td>${titleBlock}</td>
          ${companyTd}
          <td class="td-cats"><div class="cat-wrap">${renderCategoriesCell(r.categoryTags)}</div></td>
          <td>${d? d.toLocaleDateString('tr-TR') : '-'}</td>
          <td>${statusText}</td>
          <td>${bidDisplay}</td>
          <td><a href="${detailLink('incoming')}">Görüntüle →</a></td>`
          : `
          <td>${r.satfk || '-'}</td>
          <td>${titleBlock}</td>
          <td class="td-cats"><div class="cat-wrap">${renderCategoriesCell(r.categoryTags)}</div></td>
          <td>${d? d.toLocaleDateString('tr-TR') : '-'}</td>
          <td>${statusText}</td>
          <td>${bidDisplay}</td>
          <td><a href="${detailLink('outgoing')}">Görüntüle →</a></td>`;
        
        // Data attributes ekle
        tr.dataset.id = r.id;
        tr.dataset.recipientStatus = r.recipientStatus || 'pending';
        tr.dataset.biddingMode = r.biddingMode || 'secret';
        tr.dataset.visibility = r.visibility || 'public';
        tr.dataset.published = r.published ? 'true' : 'false';
        
        tb.appendChild(tr);
      }
    }

    // Load incoming demands (assigned to supplier)
    let INCOMING_ALL_ROWS = [];

    function fmtDateCell(d){ return d? d.toLocaleDateString('tr-TR') : '-'; }

    function demandRowHtml(r, isIncoming){
      const d = r._dueDate || null;
      const statusText = translateStatus(r.recipientStatus || r.status || (r.isPublished ? 'published' : 'draft'));
      const bidCount = typeof r._bidCount === 'number' ? r._bidCount : 0;
      const bidDisplay = bidCount > 0 
        ? `<span style="background:#d1fae5;color:#065f46;padding:2px 6px;border-radius:4px;font-size:12px">${bidCount} teklif</span>`
        : '<span style="color:#6b7280;font-size:12px">Henüz teklif yok</span>';
      const companyName = r.companyName || r.company?.name || 'Bilinmeyen Firma';
      const companyTd = isIncoming ? `<td><span style=\"background:#e0f2fe;color:#0277bd;padding:2px 6px;border-radius:4px;font-size:12px\">${companyName}</span></td>` : '';
      const detailLink = (src) => `demand-detail.html?id=${encodeURIComponent(r.id)}&source=${src}`;
      const fi = r._firstItem || {};
      const thumb = fi.imageUrl ? `<img src="${fi.imageUrl}" alt="" style="width:44px;height:44px;object-fit:cover;border-radius:6px;border:1px solid #e5e7eb;margin-right:8px;">` : '';
      const titleBlock = `
        <div style="display:flex;align-items:center;">
          ${thumb}
          <div>
            <div style="font-weight:600;color:#111827;">${r.title || '-'}</div>
            ${fi.target || r.targetPrice ? `<div style=\"font-size:12px;color:#6b7280;\">Hedef: ${(fi.target || r.targetPrice)}</div>` : ''}
          </div>
        </div>`;
      return `
        <td>${r.satfk || '-'}</td>
        <td>${titleBlock}</td>
        ${companyTd}
        <td class="td-cats"><div class="cat-wrap">${renderCategoriesCell(r.categoryTags)}</div></td>
        <td>${fmtDateCell(d)}</td>
        <td>${statusText}</td>
        <td>${bidDisplay}</td>
        <td><a href="${detailLink('incoming')}">Görüntüle →</a></td>`;
    }

    async function markOwnBidFlags(rows, u){
      // For each demand, detect if current user has a bid
      for (const r of rows) {
        try {
          // Try composite query first
          const qOwn = query(collection(db,'bids'), where('demandId','==', r.id), where('supplierId','==', u.uid), limit(1));
          const s = await getDocs(qOwn);
          r.hasOwnBid = s.docs.length > 0;
        } catch (e) {
          // Fallback: query by demand only and filter in-memory
          try {
            const qAlt = query(collection(db,'bids'), where('demandId','==', r.id), limit(10));
            const s2 = await getDocs(qAlt);
            r.hasOwnBid = s2.docs.some(d => (d.data()?.supplierId) === u.uid);
          } catch {
            r.hasOwnBid = false;
          }
        }
      }
      return rows;
    }

    function renderIncomingGroups(rows){
      const bodyGiven = document.getElementById('incomingRowsGiven');
      const bodyWaiting = document.getElementById('incomingRowsWaiting');
      const emptyEl = document.getElementById('incomingEmpty');
      if (bodyGiven) bodyGiven.innerHTML = '';
      if (bodyWaiting) bodyWaiting.innerHTML = '';
      const filtered = rows || [];
      const given = filtered.filter(r => r.hasOwnBid);
      const waiting = filtered.filter(r => !r.hasOwnBid);
      if ((given.length + waiting.length) === 0) { if (emptyEl) emptyEl.classList.remove('hidden'); return; } else { if (emptyEl) emptyEl.classList.add('hidden'); }
      if (bodyGiven) {
        for (const r of given) {
          const tr = document.createElement('tr'); tr.dataset.id = r.id; tr.dataset.recipientStatus = r.recipientStatus || 'pending'; tr.dataset.biddingMode = r.biddingMode || 'secret'; tr.dataset.visibility = r.visibility || 'public';
          // Normalize due date for display cache
          let d=null; if (r.dueDate?.toDate) d=r.dueDate.toDate(); else if (r.dueDate) d=new Date(r.dueDate); else if (r.deadline?.toDate) d=r.deadline.toDate(); else if (r.deadline) d=new Date(r.deadline); r._dueDate=d;
          tr.innerHTML = demandRowHtml(r, true);
          bodyGiven.appendChild(tr);
        }
      }
      if (bodyWaiting) {
        for (const r of waiting) {
          const tr = document.createElement('tr'); tr.dataset.id = r.id; tr.dataset.recipientStatus = r.recipientStatus || 'pending'; tr.dataset.biddingMode = r.biddingMode || 'secret'; tr.dataset.visibility = r.visibility || 'public';
          let d=null; if (r.dueDate?.toDate) d=r.dueDate.toDate(); else if (r.dueDate) d=new Date(r.dueDate); else if (r.deadline?.toDate) d=r.deadline.toDate(); else if (r.deadline) d=new Date(r.deadline); r._dueDate=d;
          tr.innerHTML = demandRowHtml(r, true);
          bodyWaiting.appendChild(tr);
        }
      }
    }

    async function loadIncoming(u){
      try {
        console.log("Loading all published demands...");
        // Load current user's category slugs
        const meDoc = await getDoc(doc(db, 'users', u.uid));
        const myData = meDoc.exists() ? meDoc.data() : {};
        const myCats = Array.isArray(myData.supplierCategories) ? myData.supplierCategories : [];
        const myCatSlugs = new Set(myCats.map(toSlug));
        
        // Tüm yayınlanmış talepleri al
        const q = query(
          collection(db,'demands'), 
          where('isPublished', '==', true),
          orderBy('createdAt', 'desc'), 
          limit(100)
        );
        
        const snap = await getDocs(q);
        console.log(`Found ${snap.docs.length} published demands`);
        
        let rows = snap.docs
          .filter(d => d.data().createdBy !== u.uid) // Kendi taleplerini filtrele
          .map(d => ({ id: d.id, ...d.data() }));

        // Filter by creator role=buyer and category overlap
        const creatorIds = Array.from(new Set(rows.map(r => r.createdBy).filter(Boolean)));
        const creatorCache = new Map();
        await Promise.all(creatorIds.map(async (cid) => {
          try { const cdoc = await getDoc(doc(db, 'users', cid)); creatorCache.set(cid, cdoc.exists() ? cdoc.data() : {}); } catch(e){ creatorCache.set(cid, {}); }
        }));

        // Load company names by companyId if available (from demand or creator profile)
        const companyIds = new Set(rows.map(r => r.companyId).filter(Boolean));
        creatorIds.forEach(cid => {
          const c = creatorCache.get(cid) || {};
          if (c.companyId) companyIds.add(c.companyId);
        });
        const companyIdList = Array.from(companyIds);
        const companyCache = new Map();
        await Promise.all(companyIdList.map(async (compId) => {
          try { const cdoc = await getDoc(doc(db, 'companies', compId)); companyCache.set(compId, cdoc.exists() ? cdoc.data() : {}); } catch(e){ companyCache.set(compId, {}); }
        }));

        rows = rows.filter(r => {
          const creator = creatorCache.get(r.createdBy) || {};
          const roles = Array.isArray(creator.roles) ? creator.roles.map(x=>String(x).toLowerCase()) : [];
          const isBuyer = roles.includes('buyer');
          const demandCats = Array.isArray(r.categoryTags) ? r.categoryTags : [];
          const hasOverlap = demandCats.some(c => myCatSlugs.has(toSlug(c)));
          return isBuyer && hasOverlap;
        }).map(r => {
          // ensure fields for renderer/filters
          r.biddingMode     = r.biddingMode || 'secret';
          r.visibility      = r.visibility || 'public';
          r.recipientStatus = 'available';
          const creator     = creatorCache.get(r.createdBy) || {};
          const comp        = companyCache.get(r.companyId) || companyCache.get(creator.companyId) || {};
          r.companyName     = pickCompanyName({ demandRow: r, creatorProfile: creator, companyDoc: comp });
          return r;
        });
        
        console.log(`Processed ${rows.length} demands (filtered by buyer+category overlap)`);
        
        // Kendi teklif durumunu işaretle
        await markOwnBidFlags(rows, u);
        // Bid sayısını da önceden hesapla (opsiyonel)
        for (const r of rows) {
          try {
            const bidSnap = await getDocs(query(collection(db,'bids'), where('demandId','==', r.id)));
            r._bidCount = bidSnap.docs.length;
          } catch { r._bidCount = 0; }
        }

        // Load first item meta (image/target) for visual summary
        await loadFirstItemMeta(rows);
        INCOMING_ALL_ROWS = rows;
        renderIncomingGroups(INCOMING_ALL_ROWS);
        await applyIncomingFilters(INCOMING_ALL_ROWS);
      } catch (err){
        console.error('incoming load error', err);
        showIndexHint(err);
      }
    }
    
    // Gelen talepler için filtre uygulama
    async function applyIncomingFilters(allRows = null) {
      let rows = allRows || INCOMING_ALL_ROWS || [];
      // Durum filtresi
      const status = fIncomingStatus?.value || "";
      if (status) {
        rows = rows.filter(row => {
          if (status === 'pending') return row.recipientStatus === 'pending';
          if (status === 'viewed') return row.recipientStatus === 'viewed';
          if (status === 'responded') return row.recipientStatus === 'responded';
          return true;
        });
      }
      // Talep Tipi filtresi (gelen talepler için)
      const mode = fBiddingMode?.value || "";
      if (mode) rows = rows.filter(row => (row.biddingMode || 'secret') === mode);
      // Render split tables
      renderIncomingGroups(rows);
    }

    // Giden talepler için filtre uygulama
    // Not: Giden talepler sadece published=true olanları gösterdiği için filtreye gerek yok
    async function applyOutgoingFilters() {
      // Filtre devre dışı - artık loadOutgoing sadece published talepleri yüklüyor
      console.log("Giden talepler filtresi devre dışı - sadece yayınlanmış talepler gösteriliyor");
    }

    // Hata mesajı index için
    function showIndexHint(err) {
      const emptyEl = document.querySelector('#incomingEmpty');
      if (emptyEl) {
        if (String(err.message || err).includes('index')) {
          emptyEl.textContent = 'Firestore dizini hazırlanıyor. Konsoldaki "Create index" linkine tıklayıp Ready olunca sayfayı yenileyin.';
        } else {
          emptyEl.textContent = 'Gelen talepler yüklenemedi.';
        }
        emptyEl.classList.remove('hidden');
      }
    }

    // Load outgoing demands (created by user) - Only published demands
    async function loadOutgoing(u){
      try {
        // Get published demands created by user
        const q = query(
          collection(db,'demands'), 
          where('createdBy','==', u.uid),
          where('published','==', true),
          orderBy('createdAt','desc'), 
          limit(100)
        );
        const snap = await getDocs(q);
        const rows = snap.docs.map(d=>({ id:d.id, ...d.data() }));
        console.log(`✅ Loaded ${rows.length} published outgoing demands`);
        await loadFirstItemMeta(rows);
        await render(rows, '#outgoingRows', '#outgoingEmpty');
      } catch (err){
        console.error('outgoing load error', err);
        const emptyEl = document.querySelector('#outgoingEmpty');
        if (emptyEl) {
          if (String(err.message || err).includes('index')) {
            emptyEl.textContent = 'Firestore dizini hazırlanıyor. Konsoldaki "Create index" linkine tıklayıp Ready olunca sayfayı yenileyin.';
          } else {
            emptyEl.textContent = 'Giden talepler yüklenemedi.';
          }
          emptyEl.classList.remove('hidden');
        }
      }
    }

    // Load draft demands with cursor-based pagination
    async function loadDraftPaged(u, { append = false } = {}){
      if (isLoadingDrafts) return;
      
      try {
        isLoadingDrafts = true;
        console.log("Loading draft demands for user:", u.uid, "append:", append);
        
        // İlk yüklemede listeyi sıfırla
        if (!append) {
          accumulatedDrafts = [];
          lastDraftDoc = null;
          draftsFinished = false;
        }
        
        // Build query with cursor
        let q = query(
          collection(db,'demands'), 
          where('createdBy','==', u.uid),
          orderBy('createdAt','desc'), 
          limit(DRAFT_PAGE_SIZE)
        );
        
        // Add cursor if we have a last document
        if (lastDraftDoc) {
          q = query(
            collection(db,'demands'), 
            where('createdBy','==', u.uid),
            orderBy('createdAt','desc'),
            startAfter(lastDraftDoc),
            limit(DRAFT_PAGE_SIZE)
          );
        }
        
        const snap = await getDocs(q);
        console.log(`Found ${snap.docs.length} demands`);
        
        // published === false olanları filtrele
        const draftRows = snap.docs
          .filter(d => d.data().published === false)
          .map(d => {
            const demandData = { id: d.id, ...d.data() };
            demandData.statusText = translateStatus(demandData.status || 'draft');
            return demandData;
          });
        
        console.log(`Filtered to ${draftRows.length} draft demands`);
        
        // Verileri birleştir
        accumulatedDrafts = [...accumulatedDrafts, ...draftRows];
        
        // Son dökümanı kaydet
        if (snap.docs.length > 0) {
          lastDraftDoc = snap.docs[snap.docs.length - 1];
        }
        
        // Sayfa bitince finished flag'i set et
        if (snap.docs.length < DRAFT_PAGE_SIZE) {
          draftsFinished = true;
        }
        
        // Render
        await renderDraft(accumulatedDrafts, '#draftRows', '#draftEmpty');
        
        // Sayfa bitince "Daha Fazla" butonunu gizle
        const loadMoreBtn = document.getElementById('loadMoreDraftsBtn');
        if (draftsFinished) {
          // Veri yok, butonu gizle
          if (loadMoreBtn) loadMoreBtn.classList.add('hidden');
        } else {
          // Veri var, butonu göster
          if (loadMoreBtn) loadMoreBtn.classList.remove('hidden');
        }
        
      } catch (err){
        console.error('draft load error', err);
        const emptyEl = document.querySelector('#draftEmpty');
        if (emptyEl) {
          if (String(err.message || err).includes('index')) {
            emptyEl.textContent = 'Firestore dizini hazırlanıyor. Konsoldaki "Create index" linkine tıklayıp Ready olunca sayfayı yenileyin.';
          } else {
            emptyEl.textContent = 'Taslak talepler yüklenemedi.';
          }
          emptyEl.classList.remove('hidden');
        }
      } finally {
        isLoadingDrafts = false;
      }
    }
    
    // Backward compatibility wrapper
    async function loadDraft(u, append = false) {
      return loadDraftPaged(u, { append });
    }
    
    // Daha fazla taslak yükleme fonksiyonu
    window.loadMoreDrafts = function() {
      loadDraftPaged(user, { append: true });
    };

    // Taslak talepler için action fonksiyonları
    window.editDraftDemand = function(demandId) {
      location.href = `./demand-new.html?edit=${demandId}`;
    };
    
    window.approveDraftDemand = async function approveDraftDemand(demandId, companyId = null) {
      if (!confirm('Bu talebi onaylayıp yayınlamak istediğinizden emin misiniz?')) {
        return;
      }
      
      try {
        // Path seçimi: companyId verilmişse company altı, değilse global
        const ref = companyId
          ? doc(db, "companies", companyId, "demands", demandId)
          : doc(db, "demands", demandId);

        // Talep durumunu 'approved' yap ve yayınla
        await updateDoc(ref, {
          status: 'approved',
          published: true,
          isPublished: true,
          statusHistory: arrayUnion({
            status: 'approved',
            timestamp: Date.now(),
            userId: user.uid,
            note: 'Taslak onaylandı ve yayınlandı'
          }),
          updatedAt: serverTimestamp(),
          approvedAt: serverTimestamp()
        });
        
        console.log("✅ Draft approved:", ref.path);
        
        // Tedarikçi eşleştirmesi yap
        await publishDemandAndMatchSuppliers(demandId);
        
        alert('✅ Talep onaylandı ve tedarikçi firmalara gönderildi!');
        loadDraft(user); // Listeyi yenile
        
      } catch (error) {
        console.error('Talep onaylama hatası (approveDraftDemand):', error);
        alert('❌ Talep onaylanırken hata oluştu: ' + (error && error.message ? error.message : error));
      }
    };

    // Toplu silme yardımcıları
    const draftSelectAll = document.getElementById('draftSelectAll');
    const btnDeleteSelectedDrafts = document.getElementById('btnDeleteSelectedDrafts');
    const btnClearDraftSelection = document.getElementById('btnClearDraftSelection');

    if (draftSelectAll) {
      draftSelectAll.addEventListener('change', () => {
        document.querySelectorAll('.draft-select').forEach(ch => ch.checked = draftSelectAll.checked);
      });
    }

    if (btnClearDraftSelection) {
      btnClearDraftSelection.addEventListener('click', () => {
        if (draftSelectAll) draftSelectAll.checked = false;
        document.querySelectorAll('.draft-select').forEach(ch => ch.checked = false);
      });
    }

    if (btnDeleteSelectedDrafts) {
      btnDeleteSelectedDrafts.addEventListener('click', async () => {
        const ids = Array.from(document.querySelectorAll('.draft-select:checked')).map(ch => ch.getAttribute('data-id'));
        if (!ids.length) { alert('Silmek için en az bir taslak seçin.'); return; }
        if (!confirm(`${ids.length} taslak talebi silmek istediğinize emin misiniz?`)) return;
        for (const id of ids) {
          await deleteDraftDemand(id);
        }
      });
    }

    // Taslak talep silme
    window.deleteDraftDemand = async function deleteDraftDemand(demandId) {
      if (!confirm('Bu taslak talebi kalıcı olarak silmek istiyor musunuz? Bu işlem geri alınamaz.')) return;
      try {
        // Alt koleksiyon: items
        try {
          const itemsSnap = await getDocs(collection(db, 'demands', demandId, 'items'));
          await Promise.all(itemsSnap.docs.map(d => deleteDoc(doc(db, 'demands', demandId, 'items', d.id))));
        } catch (e) { console.warn('items cleanup warn', e); }

        // bids (top-level)
        try {
          const bidsSnap = await getDocs(query(collection(db, 'bids'), where('demandId','==', demandId)));
          await Promise.all(bidsSnap.docs.map(d => deleteDoc(doc(db, 'bids', d.id))));
        } catch (e) { console.warn('bids cleanup warn', e); }

        // recipients (top-level)
        try {
          const recSnap = await getDocs(query(collection(db, 'demandRecipients'), where('demandId','==', demandId)));
          await Promise.all(recSnap.docs.map(d => deleteDoc(doc(db, 'demandRecipients', d.id))));
        } catch (e) { console.warn('recipients cleanup warn', e); }

        // Ana doküman
        await deleteDoc(doc(db, 'demands', demandId));

        // UI'dan kaldır
        const tr = document.querySelector(`#draftRows tr[data-id="${demandId}"]`);
        if (tr) tr.remove();
        accumulatedDrafts = accumulatedDrafts.filter(x => x.id !== demandId);
        if (accumulatedDrafts.length === 0) {
          const emptyEl = document.querySelector('#draftEmpty');
          if (emptyEl) emptyEl.classList.remove('hidden');
        }
        alert('🗑️ Taslak talep silindi.');
      } catch (err) {
        console.error('deleteDraft error', err);
        alert('❌ Taslak silinemedi: ' + (err.message || err));
      }
    };
    
    window.deleteDraftDemand = async function(demandId) {
      if (!confirm('Bu talebi silmek istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
        return;
      }
      
      try {
        // Talep ve alt koleksiyonlarını sil
        await deleteDoc(doc(db, 'demands', demandId));
        
        alert('✅ Talep silindi.');
        loadDraft(user); // Listeyi yenile
        
      } catch (error) {
        console.error('Talep silme hatası:', error);
        alert('❌ Talep silinirken hata oluştu: ' + error.message);
      }
    };

    // Tedarikçi eşleştirme fonksiyonu
    async function publishDemandAndMatchSuppliers(demandId) {
      try {
        console.log("Publishing demand and matching suppliers:", demandId);
        
        // Talep verilerini al
        const demandDoc = await getDoc(doc(db, 'demands', demandId));
        if (!demandDoc.exists()) {
          throw new Error('Talep bulunamadı');
        }
        
        const demandData = demandDoc.data();
        const categories = demandData.categoryTags || [];
        const groups = demandData.groupIds || [];
        
        console.log('Demand categories:', categories);
        console.log('Demand groups:', groups);
        
        // Tedarikçi sorguları
        const supplierQueries = [];
        
        // Kategori bazlı tedarikçi sorgusu
        if (categories.length > 0) {
          supplierQueries.push(
            query(
              collection(db, 'users'),
              where('isActive', '==', true),
              where('supplierCategories', 'array-contains-any', categories.slice(0, 10))
            )
          );
        }
        
        // Grup bazlı tedarikçi sorgusu
        if (groups.length > 0) {
          supplierQueries.push(
            query(
              collection(db, 'users'),
              where('isActive', '==', true),
              where('groupIds', 'array-contains-any', groups)
            )
          );
        }
        
        // Özel talep için seçilen tedarikçiler
        if (demandData.demandType === 'private' && demandData.selectedSuppliers) {
          for (const supplierId of demandData.selectedSuppliers) {
            supplierQueries.push(
              query(
                collection(db, 'users'),
                where('isActive', '==', true),
                where('__name__', '==', supplierId)
              )
            );
          }
        }
        
        // Tüm sorguları çalıştır ve benzersiz tedarikçileri bul
        const allSuppliers = new Set();
        
        for (const q of supplierQueries) {
          try {
            const snap = await getDocs(q);
            snap.docs.forEach(doc => {
              if (doc.id !== demandData.createdBy) { // Kendi kendine gönderme
                allSuppliers.add(doc.id);
              }
            });
          } catch (queryError) {
            console.warn('Supplier query failed:', queryError);
          }
        }
        
        console.log('Found suppliers:', allSuppliers.size);
        
        // demandRecipients kayıtları oluştur
        const recipientPromises = Array.from(allSuppliers).map(supplierId => 
          addDoc(collection(db, 'demandRecipients'), {
            demandId: demandId,
            buyerId: demandData.createdBy,
            supplierId: supplierId,
            matchedAt: serverTimestamp(),
            status: 'pending',
            createdAt: serverTimestamp()
          })
        );
        
        await Promise.all(recipientPromises);
        
        console.log(`✅ Created ${recipientPromises.length} demandRecipients records`);
        
      } catch (error) {
        console.error('Error in publishDemandAndMatchSuppliers:', error);
        throw error;
      }
    }

    // Always load data
    await loadIncoming(user);
    await loadOutgoing(user);
    await loadDraft(user);

    // Check URL parameters for dashboard navigation
    const filter = urlParams.get('filter');
    
    if (filter) {
      // Apply filter based on URL parameter
      if (filter === 'inbox') {
        showTab('incoming');
      } else if (filter === 'outgoing') {
        showTab('outgoing');
      } else if (filter === 'draft') {
        showTab('draft');
        loadDraft(user); // Taslak talepleri yükle
      }
    } else {
      // Default behavior
      showTab('incoming');
    }

    // --- Filters ---
    [fStatus, fPriority, fBiddingMode, fGroup].forEach(el => el && el.addEventListener("change", applyFilters));
    
    // Gelen talepler için filtreler
    fIncomingStatus?.addEventListener("change", async () => await applyIncomingFilters());
    
    // Giden talepler için filtreler
    fStatus?.addEventListener("change", async () => await applyOutgoingFilters());

    // Initial render
    applyFilters();

    // ====================
    // Apply Filters
    // ====================
    function applyFilters(){
      let rows = [...merged];

      // Durum
      const status = fStatus?.value || "";
      if (status==="draft") {
        rows = rows.filter(d => d.status === 'draft' || (!d.published && !d.isPublished));
      } else if (status==="published") {
        rows = rows.filter(d => d.status !== 'draft' && (d.published || d.isPublished));
      }

      // Öncelik
      const prio = fPriority?.value || "";
      if (prio) rows = rows.filter(d => (d.priority||"")=== prio);

      // Talep Tipi
      const mode = fBiddingMode?.value || "";
      if (mode) rows = rows.filter(d => (d.biddingMode||"secret")===mode);

      const groupBy = fGroup?.value || "";
      if (groupBy) {
        renderGrouped(buildGroups(rows, groupBy));
        bindDeleteButtons("#grouped-container");
      } else {
        currentPage = 0;
        renderTable(rows);
        renderPagination(rows);
        bindDeleteButtons("#demands-body");
      }
    }

    // ====================
    // Grouping Functions
    // ====================
    function groupKey(rec, by) {
      switch (by) {
        case "site":
          return rec.siteName || "— (Şantiye yok) —";
        case "status":
          // Önce status alanını kontrol et, sonra published/isPublished
          const isDraft = rec.status === 'draft' || (!rec.published && !rec.isPublished);
          return isDraft ? "Taslak" : "Gönderildi";
        case "priority":
          return rec.priority || "—";
        case "biddingmode": {
          const mode = rec.biddingMode || "secret";
          const labels = { secret: "Gizli", open: "Açık Artırma", hybrid: "Hibrit" };
          return labels[mode] || "Gizli";
        }
        case "category": {
          const cats = [
            ...(Array.isArray(rec.categoryTags) ? rec.categoryTags : []),
            ...(rec.customCategory ? [rec.customCategory] : [])
          ];
          return cats.length ? cats : ["— (Kategori yok) —"];
        }
        case "month": {
          const d = rec.createdAt?.toDate?.();
          if (!d) return "— (Tarih yok) —";
          const m = (d.getMonth() + 1).toString().padStart(2, "0");
          return `${d.getFullYear()}-${m}`;
        }
        default:
          return "";
      }
    }

    function buildGroups(rows, by) {
      const map = new Map();
      for (const r of rows) {
        const k = groupKey(r, by);
        const keys = Array.isArray(k) ? k : [k];
        keys.forEach(key => {
          if (!map.has(key)) map.set(key, []);
          map.get(key).push(r);
        });
      }
      return map; // Map<groupName, Record[]>
    }

    function renderGrouped(groupsMap) {
      const wrap = document.getElementById("grouped-container");
      const tbody = document.getElementById("demands-body");
      const pager = document.getElementById("pager");
      wrap.innerHTML = "";
      wrap.style.display = "";
      tbody.innerHTML = "";
      pager.style.display = "none"; // Hide pagination in grouped view

      // Sort groups by name
      const entries = [...groupsMap.entries()].sort((a, b) => a[0].localeCompare(b[0], "tr"));

      for (const [gname, list] of entries) {
        // Group header (collapsible)
        const openId = Math.random().toString(36).slice(2, 8);
        const header = document.createElement("div");
        header.style.cssText = "margin:12px 0 4px 0; font-weight:600; cursor:pointer; font-size:16px;";
        header.innerHTML = `${gname} <span style="opacity:.7">(${list.length})</span>`;
        const cont = document.createElement("div");
        cont.id = `grp-${openId}`;

        // Mini table
        const tbl = document.createElement("table");
        tbl.className = "table";
        const head = document.createElement("thead");
        head.innerHTML = document.querySelector("thead").innerHTML;
        const body = document.createElement("tbody");
        list
          .sort((a, b) => (b.createdAt?.toMillis?.() || 0) - (a.createdAt?.toMillis?.() || 0))
          .forEach(d => body.appendChild(rowHtml(d)));
        tbl.appendChild(head);
        tbl.appendChild(body);
        cont.appendChild(tbl);

        // Toggle
        let visible = true;
        header.onclick = () => {
          visible = !visible;
          cont.style.display = visible ? "" : "none";
        };

        wrap.appendChild(header);
        wrap.appendChild(cont);
      }
    }

    // --- Row HTML (gerçek <td>'ler!) ---
    function rowHtml(d){
      const tr = document.createElement("tr");

      const cats = [
        ...(Array.isArray(d.categoryTags)?d.categoryTags:[]),
        ...(d.customCategory?[d.customCategory]:[])
      ];
      const catsHtml = cats.slice(0,3).map(c=>`<span class="badge">${c}</span>`).join(" ") + (cats.length>3?` +${cats.length-3}`:""  );

      const mode = d.biddingMode || "secret";
      const modeLabel = ({secret:"Gizli", open:"Çık", hybrid:"Hibrit"})[mode] || "Gizli";

      const isOwner = d.createdBy === uid;
      const created = d.createdAt?.toDate?.()?.toLocaleDateString?.("tr-TR") || "-";

      tr.innerHTML = `
        <td>${d.satfk || "-"}</td>
        <td><a href="./demand-detail.html?id=${d.id}">${d.title || "-"}</a></td>
        <td>${catsHtml || "-"}</td>
        <td>${d.dueDate || "-"}</td>
        <td>${d.priority || "-"}</td>
        <td>${modeLabel}</td>
        <td>${d.siteName || "-"}</td>
        <td>${(d.status === 'draft' || (!d.published && !d.isPublished)) ? '<span class="badge warn">Taslak</span>' : '<span class="badge success">Gönderildi</span>'}</td>
        <td>${created}</td>
        <td>${isOwner ? `<button class="danger small" data-id="${d.id}">Sil</button>` : ""}</td>
      `;
      return tr;
    }

    // --- Table render ---
    function renderTable(list){
      groupedWrap.style.display = "none";
      tbody.innerHTML = "";
      pager.style.display = "";

      const start = currentPage * PAGE_SIZE;
      list.slice(start, start+PAGE_SIZE).forEach(d => tbody.appendChild(rowHtml(d)));
    }
    function renderPagination(list){
      const total = list.length;
      const totalPages = Math.max(1, Math.ceil(total/PAGE_SIZE));
      if (totalPages<=1){ pager.innerHTML = `Toplam ${total} talep`; return; }
      pager.innerHTML = `
        <button ${currentPage<=0?"disabled":""} id="prevBtn">← Önceki</button>
        <span> Sayfa ${currentPage+1} / ${totalPages} (Toplam ${total} talep) </span>
        <button ${currentPage>=totalPages-1?"disabled":""} id="nextBtn">Sonraki →</button>
      `;
      const prev = document.getElementById("prevBtn");
      const next = document.getElementById("nextBtn");
      if (prev) prev.onclick = ()=>{ if (currentPage>0){ currentPage--; renderTable(list); renderPagination(list); bindDeleteButtons("#demands-body"); } };
      if (next) next.onclick = ()=>{ if (currentPage<totalPages-1){ currentPage++; renderTable(list); renderPagination(list); bindDeleteButtons("#demands-body"); } };
    }

    // --- Delete bind (owner only) ---
    function bindDeleteButtons(scopeSelector){
      document.querySelectorAll(`${scopeSelector} button.danger`).forEach(btn=>{
        btn.onclick = async ()=>{
          const id = btn.getAttribute("data-id");
          if (!confirm("Bu talebi silmek istiyor musunuz?")) return;
          try{
            await deleteDoc(doc(db,"demands", id));
            merged = merged.filter(x=>x.id!==id);
            applyFilters();
            alert("✅ Talep silindi.");
          }catch(e){ alert("❌ Silinemedi: " + (e.message||e)); }
        };
      });
    }
    })();

    // Listen for company changes
    window.addEventListener('company:changed', async (e) => {
      const { companyId } = e.detail;
      console.log('🏢 Company changed, reloading data for:', companyId);
      
      // Re-run queries with new company
      await loadIncoming();
      await loadOutgoing();
      await loadDraft();
    });
  </script>

  <!-- Theme Script -->
  <script src="/assets/js/theme.js" defer></script>

  <script type="module" src="/js/ui-standard.js"></script>
</body>
</html>